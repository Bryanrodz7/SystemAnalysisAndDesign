# SystemAnalysisAndDesign
System Analysis And Design Class projects
# CS 300 â€“ Data Structures and Algorithms Portfolio

## Project Overview
The projects in this course focused on using data structures and algorithms to organize, store, and retrieve data efficiently. In Project One, I analyzed the runtime and memory trade-offs of different data structures. In Project Two, I implemented a C++ advising assistance program that loads course data from a CSV file, sorts the courses alphanumerically, and allows users to view course details and prerequisites.

## What problem was I solving?
The main problem was designing a system that could efficiently store course information and allow users to retrieve sorted course lists and individual course details. This required choosing an appropriate data structure that balanced performance, simplicity, and maintainability.

## How did I approach the problem?
I approached the problem by first analyzing multiple data structure options and their runtime and memory characteristics. Understanding data structures was critical because the choice directly affected sorting efficiency, lookup speed, and overall program design. I then implemented the solution incrementally, testing each feature as it was added.

## How did I overcome roadblocks?
I encountered several challenges related to environment setup, file handling, and debugging runtime errors. I overcame these by breaking the problems down into smaller steps, validating assumptions through testing, and using error messages to guide fixes. This process improved my troubleshooting and debugging skills.

## How did this project expand my approach to software design?
This project reinforced the importance of planning before coding. By thinking through data structures and algorithms first, I was able to write more efficient and organized code. It also highlighted how design decisions early on can simplify later development.

## How has this project influenced how I write maintainable code?
My work on this project improved how I structure programs, name variables, and write reusable functions. I now place more emphasis on readability, modularity, and adaptability so that the code can be easily updated or extended in the future.
